## 引用传递

> js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递?

简单点说, 对象是引用传递, 基础类型是值传递, 通过将基础类型包装 \(boxing\) 可以以引用的方式传递.\(复杂见注①\)

引用传递和值传递是一个非常简单的问题, 也是理解 Javascript 中的内存方面问题的一个基础. 如果不了解引用可能很难去看很多问题.

面试写代码的话, 可以通过`如何编写一个 json 对象的拷贝函数`等类似的问题来考察对引用的了解. 不过笔者偶尔会有恶趣味, 喜欢先问应聘者对于`==`的`===`的区别的了解. 然后再问`[1] == [1]`是`true`还是`false`. 如果基础不好的同学可能会被自己对于`==`和`===`的结论影响然后得出错误的结论.

注①: 对于技术好的, 希望能直接反驳这个问题本身是有问题的, 比如讲清楚 Javascript 中没有引用传递只是传递引用. 参见[Is JavaScript a pass-by-reference or pass-by-value language?](http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language). 虽然说是复杂版, 但是这些知识对于 3年经验的同学真的应该是很简单的问题了.

另外如果简历中有写 C++, 则必问`指针与引用的区别`.

[http://javascript.ruanyifeng.com/grammar/function.html\#toc19](http://javascript.ruanyifeng.com/grammar/function.html#toc19)

http://javascript.ruanyifeng.com/grammar/operator.html



### 传递方式 {#传递方式}

函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。

```js
var
p
=
2
;
function
f
(
p
)
{
p
=
3
;
}
f
(
p
);
p
// 2
```

上面代码中，变量`p`是一个原始类型的值，传入函数`f`的方式是传值传递。因此，在函数内部，`p`的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。

但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。

```
var
obj
=
{
p
:
1
};
function
f
(
o
)
{
o
.
p
=
2
;
}
f
(
obj
);
obj
.
p
// 2
```

上面代码中，传入函数`f`的是参数对象`obj`的地址。因此，在函数内部修改`obj`的属性`p`，会影响到原始值。

注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。

```
var
obj
=
[
1
,
2
,
3
];
function
f
(
o
){
o
=
[
2
,
3
,
4
];
}
f
(
obj
);
obj
// [1, 2, 3]
```

上面代码中，在函数`f`内部，参数对象`obj`被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（`o`）与实际参数`obj`存在一个赋值关系。

```
// 函数f内部
o
=
obj
;
```

上面代码中，对`o`的修改都会反映在`obj`身上。但是，如果对`o`赋予一个新的值，就等于切断了`o`与`obj`的联系，导致此后的修改都不会影响到`obj`了。

某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。

```js
var
a
=
1
;
function
f
(
p
)
{
window
[
p
]
=
2
;
}
f
(
'a'
);
a
// 2
```

上面代码中，变量`a`本来是传值传递，但是写成`window`对象的属性，就达到了传址传递的效果。

